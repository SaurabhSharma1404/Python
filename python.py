# -*- coding: utf-8 -*-
"""python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KGX0Ym5qhrRF_tYO06x2jrUxEEmIRYBh

# **Theory Questions**

# **Answer 1**

Object-oriented programming (OOP) in Python helps you structure your code by grouping related data and behaviors into objects. You start by defining classes, which act as blueprints, and then create objects from them. OOP simplifies modeling real-world concepts in your programs and enables you to build systems that are more reusable and scalable.


**Class**: A blueprint for creating objects. It defines a data structure and behaviors methods.

**Object**: An instance of a class. It holds actual values and can perform defined methods.

**Encapsulation**: Hiding internal state and requiring all interaction to be performed through an objectâ€™s methods.

**Abstraction**: Hiding complex implementation details and showing only the necessary features.

**Inheritance**: Mechanism by which one class can inherit properties and methods from another, promoting code reuse.

**Polymorphism**: The ability of different objects to respond in a unique way to the same method call.

# **Answer 2**

A class is a collection of objects. Classes are blueprints for creating objects. A class defines a set of attributes and methods that the created objects instances can have.
  

* Classes are created by keyword class.
* Attributes are the variables that belong to a class.
* Attributes are always public and can be accessed using the dot (.) operator.

# **Answer 3**

An object in Object-Oriented Programming is a data entity with unique characteristics and behaviors, resembling real-life entities with states and actions. It represents an instance of a class, that allows multiple objects from the same class to exist.

# **Answer 4**

**Abstraction-:** Abstraction means to hide the complex details from the user and showing the user only the necessary details.

* It focus on what an object is doing rather than how an object is doing.

* Example-: TV remote, it hides all the mechanism that how it is working from inside

**Encapsulation-:** It involves controlling the access to the internal data to prevent unauthorized modification. It's about how the data is managed and protected.

* There are access modifiers which allow us to protect the data which are private, protected, public.

*  Example-: Medicine capsule protecting contents

# **Answer 5**

Dunder methods, also known as magic methods, are special methods in Python that begin and end with double underscores e.g., __init__, __str__, __len__. They allow classes to define how they interact with built-in functions and operators.
Some common dunder methods include:

__init__: Initializes a new object (constructor).

__str__: Returns a string representation of an object.

__len__: Returns the length of an object.

# **Answer 6**

Inheritance means when a class called child class inherit the properties and attributes of parent class that is called inheritance.

There are mainly four types of inheritance which are-:

* Single inheritance
* multiple inheritance
* multilevel inheritance
* hierachical inheritance
"""

# example of inheritance
class father():  # parent class
  def fat (self):
    print("father loves fighting")

class son(father): # inheritance from parent class
  def sar (self):
    print("son loves boxing")

f=father()   # objects
s=son()
s.fat()  # son inherits from father class

"""# **Answer 7**

Polymorphism means an ablitity of data to be processed in more than one form and the name it self indicates poly means many and morphism means types.

"""

# example of polymorphism
def add(a,b):
  return a+b
print(add(2,3))  # interger addition
print(add("hello","world")) # string concatenation
print(add([2,3],[4,5])) # list concatenation

"""# **Answer 8**

Encapsulation involves controlling the access to the internal data to prevent unauthorized modification. It's about how the data is managed and protected.

lets see an example how encapsulation is achieved in Python
"""

class bankaccount:
  def __init__(self,account_holder,balance):
    self.account_holder=account_holder  # public
    self.__balance=balance # private
  def deposit(self,amount):
    if amount>0:
      self.__balance += amount
    else:
      print("invalid amount")

  def withdraw (self,amount):
    if 0<amount<=self.__balance:
      self.__balance -= amount
    else:
      print("invalid balance")

  def get_balance(self):
    return self.__balance

acc = bankaccount("saurabh",100000)
acc.deposit(100000)
acc.get_balance() # by print function it cannot be accessed directly

"""# **Answer 9**

A constructor in Python is a special method within a class that initializes the attributes of an object when the object is created. It is automatically called when an instance of the class is instantiated. The constructor method is named __init__ and always takes **self** as its first argument, which refers to the instance being created. It can also accept additional arguments to initialize the object's attributes with specific values.
"""

class Dog:
    def __init__(self, name, breed): # __init__ is a constructor
        self.name = name
        self.breed = breed

    def bark(self):
        print("Woof!")

my_dog = Dog("Buddy", "Golden Retriever")
print(my_dog.name)
print(my_dog.breed)
my_dog.bark()

"""# **Answer 10**

**Class Method-:** The class method is an inbuilt functions in python, which return a class as class method for a given function. It transforms a method into a class method. when a method is is defined using @classmethod decorator, the method is bound to the class and not to the instance of the class. As the result method recives the class (cls) as the first argument rather than instance self.

**Static Method-:** A static method is a method that is bound to a class but not the objects of the class. It can not access or modify class state. It not use self or cls.


"""

class class_method:
  @classmethod
  def cla(cls):
    print("this is a class method")

  @staticmethod
  def cvv():
    print("this is a static method")

class_method.cla()
class_method.cvv()

"""# **Answer 11**

Method overloading means two or more methods have the same name but different numbers of parameters or different types of parameter or both. These methods are called overloaded methods.

And in python method overloading not works but we can implement method overloading using another way lets see an example
"""

class shape:
  def area(self,a,b=0):
    if b==0:
      return 3.14*a*a
    else:
      return a*b

s = shape()
print(s.area(2))
print(s.area(4,3))
# in this way we can achive method overloading in python and this is one of the way

"""# **Answer 12**

Method overriding is a method when a child class has a same name, the same parameter or signature and same return type as a method in parent class,  then the method in child class is said to override the method in parent class.

Lets understand with the help of example-:


"""

class phone:
  def __init__(self,price,brand,model):
    self.price = price
    self.brand = brand
    self.model = model
  def buy(self):  # method name same
    print("buying a phone")

class smartphone(phone):
  def buy(self):   # same method name as above
    print("buying a smartphone")

s = smartphone(20000,"iphone",13)
s.buy() # this override the parent and child class print will be displayed

"""# **Answer 13**

The property decorator in Python is used to define methods in a class that can be accessed like attributes. It allows you to implement getter, setter, and deleter methods in a clean and Pythonic way without explicitly calling them as methods.

# **Answer 14**

**Flexibility and Extensibility:**
Polymorphism enables you to write code that can work with objects of different classes without needing to know their specific type. This makes your code more flexible and easier to extend in the future.

**Code Reusability:**
By using polymorphism, you can write generic code that can be reused with different types of objects. This reduces code duplication and makes your code more maintainable.

**Abstraction:**
Polymorphism allows you to abstract away the specific implementation details of different classes. This makes your code easier to understand and reason about.

**Loose Coupling:**
Polymorphism promotes loose coupling between different parts of your code. This means that changes in one part of your code are less likely to affect other parts.

**Method Overriding:**
Polymorphism enables method overriding, where a subclass can provide its own implementation of a method that is already defined in its superclass. This allows you to customize the behavior of objects based on their specific type.

# **Answer 15**

In Python, an abstract class is a class that cannot be instantiated on its own and is designed to be a blueprint for other classes. Abstract classes allow us to define methods that must be implemented by subclasses, ensuring a consistent interface while still allowing the subclasses to provide specific implementations.
"""

from abc import ABC, abstractmethod
# Define an abstract class
class Animal(ABC):

    @abstractmethod
    def sound(self):
        pass

# Concrete subclass of Animal
class Dog(Animal):

    def sound(self):
        return "Bark"  # Providing the implementation of the abstract method

dog = Dog()
print(dog.sound())

"""# **Answer 16**

1. Modularity-:Code is organized into classes and objects, which encapsulate data and behavior.Makes it easier to divide a program into smaller, manageable parts.

2. Reusability-: Through inheritance, you can create new classes from existing ones.

3. Encapsulation-: Internal object details are hidden from the outside via private/protected members and public interfaces.Improves security and reduces the likelihood of unintended interference.

4. Polymorphism-: The same method name can be used for different types of objects (via method overriding/overloading). Enhances flexibility and makes code easier to extend and maintain.

5. Abstraction-:Hides complex implementation details and exposes only necessary parts of an object. Helps in focusing on what an object does instead of how it does it.

6. Improved Code Organization-: Grouping related functions and data into classes makes the code more intuitive and aligned with real-world entities.

7. Scalability-: Easier to build large systems by dividing functionality into interacting objects.

# **Answer 17**

**class variable** is a variable that is defined within a class and outside of any class method. It is a variable that is shared by all instances of the class, meaning that if the variable's value is changed, the change will be reflected in all instances of the class. Class variables help store data common to all instances of a class.

**Instance variables** are variables that are bound to an instance of a class. They are defined within the constructor (__init__) and are unique to each object. Instance variables store data or state specific to an object, and can be accessed or modified using self within the class methods
"""

class student:
  total = 0  # class variable
  def __init__(self,name):
    self.name = name # instance variable
    student.total += 1 # incrementing class variable
    def get_total(self):
      return student.total


s1 = student("saurabh Sharma")
s2 = student("ajay")
print(s1.name)
print(s2.name)
print(student.total)

"""# **Answer 18**

Multiple Inheritance means when a child class inherits from more than one parent class. lets see an example
"""

class father:
  def gardening(self):
    print("father loves gardening")

class mother:
  def cooking(self):
    print("mother loves cooking")

class child(father,mother): # inherits from more than one parent class
  def sports(self):
    print("child loves sports")

c = child()
c.gardening()
c.cooking()
c.sports()

"""# **Answer 19**

* __repr__() provides the official string representation of an object, aimed at the programmer.
* __str__() provides the informal string representation of an object, aimed at the user.

Lets understand more by an example
"""

class Book:
    def __init__(self, title, author):
        self.title = title
        self.author = author

    def __str__(self):
        return f'"{self.title}" by {self.author}'

    def __repr__(self):
        return f"Book('{self.title}', '{self.author}')"

book = Book("The Lord of the Rings", "J.R.R. Tolkien")

print(str(book))

print(repr(book))

"""# **Answer 20**

Super() function is used to refer to the parent class. It allows you to call methods defined in parent class from child class, enabling you to extend and customize the functionality inherit from parent class.

Super() is always used inside a child class and never outside a class.

Let see an example
"""

class emp():
  def __init__(self,name,age,salary):
    self.name = name
    self.age = age
    self.salary = salary

class details(emp):
  def __init__(self,name,age,salary,department,experience):
    super().__init__(name,age,salary) # calling from parent class
    self.department = department
    self.experience = experience

emp1 = details("Saurabh Sharma","23",150000,"IT","3 YEARS")
print(emp1.name)
print(emp1.age)
print(emp1.salary)
print(emp1.department)
print(emp1.experience)

"""# **Answer 21**

The __del__() method is a special method in Python that is called when an object is about to be destroyed.
"""

class Example:

    def __init__(self):
        print("Example Instance.")

    def __del__(self):
        print("Destructor called, Example deleted.")

obj = Example()
del obj

"""# **Answer 22**

Class Method-: The class method is an inbuilt functions in python, which return a class as class method for a given function. It transforms a method into a class method. when a method is is defined using @classmethod decorator, the method is bound to the class and not to the instance of the class. As the result method recives the class (cls) as the first argument rather than instance self.

Static Method-: A static method is a method that is bound to a class but not the objects of the class. It can not access or modify class state. It not use self or cls.
"""

class class_method:
  @classmethod
  def cla(cls):
    print("this is a class method")

  @staticmethod
  def cvv():
    print("this is a static method")

class_method.cla()
class_method.cvv()

"""# **Answer 23**

How Does Polymorphism Work with Inheritance?

* When a child class inherits from a parent class, it can override methods.

* The same method name can have different implementations in the parent and child classes.

* This is called method overriding, and it is a form of polymorphism.
"""

class father:
  def teaching():
    print("father loves tecahing")

class son(father):
  def teaching():
    print("son loves boxing")

s = son
s.teaching()

"""# **Answer 24**

Method chaining in Python is a technique where multiple methods are called on the same object in a single line of code. This is made possible by returning the object itself  (self) from each method. This allows you to call one method after another in a single expression, making the code more concise and expressive

# **Answer 25**

The __call__() method is a special method that allows an instance of a class to be called as a function.

In other words, if a class defines a __call__() method, then its objects can be called like a function using parentheses ().
"""

class Greeting:
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print(f"Hello, {self.name}!")

# Creating an instance
greet = Greeting("John")

# Calling the instance like a function
greet()

"""# **Practical Questions**

# **Answer 1**
"""

class animal:
  def speak():
    print("animal is angry")

class dog(animal):
  def speak():
    print("bark")

d = dog
d.speak()

"""# **Answer 2**"""

from abc import ABC, abstractmethod
class shape(ABC):
  @abstractmethod
  def area(self):
    pass

class circle(shape):
  def __init__(self,radius):
    self.radius = radius

  def area(self):
    return 3.14*self.radius*self.radius

class rectangle(shape):
  def __init__(self,l,w):
    self.l = l
    self.w = w

  def area(self):
    return self.l*self.w

c = circle(5)
r= rectangle(4,5)
print(f"The area of circle is : {c.area()}")
print(f"The area of rectangle is : {r.area()}")

"""# **Answer 3**"""

class Vehicle:
    def __init__(self, vehicle_type):
        self.type = vehicle_type

    def display_vehicle(self):
        print(f"This is a {self.type} vehicle")


class Car(Vehicle):
    def __init__(self, vehicle_type, name):
        super().__init__(vehicle_type)
        self.name = name

    def display_car(self):
        print(f"This is a {self.name} car")


class ElectricCar(Car):
    def __init__(self, vehicle_type, name, battery):
        super().__init__(vehicle_type, name)
        self.battery = battery

    def display_electriccar(self):
        print(f"This is a {self.name} {self.type} with a battery capacity of {self.battery} kWh")


e_car = ElectricCar("SUV", "Tesla", 400)
e_car.display_vehicle()
e_car.display_car()
e_car.display_electriccar()

"""# **Answer 4**"""

class bird:
  def fly(self):
    print("The bird can fly")

class Sparrow:
  def fly(self):
    print("The sparrow can fly high")

class  Penguin:
  def fly(self):
    print("the penguin can not fly")

obj1 = Sparrow()
obj2 = Penguin()
obj1.fly()
obj2.fly()

"""# **Answer 5**"""

class bankaccount:
  def __init__(self,account_holder,balance):
    self.account_holder = account_holder
    self._balance  = balance # private

  def deposit(self,amount):
    if amount>0:
      self._balance += amount
    else:
      print("Invalid amount")

  def withdraw(self,amount):
    if 0<amount<=self._balance:
      self._balance -= amount
    else:
      print("invalid balance")

  def get_balance(self):
    return self._balance

acc = bankaccount("sauarbh sharma",100000)
acc.deposit(100000)
print("Total amount in bank:",acc.get_balance()) # to access private
acc.withdraw(100000)  # for ps5 gta 6 is coming lol
print("amount left after withdrawl:",acc.get_balance())

"""# **Answer 6**"""

class Instrument:
    def play(self):
        print("Playing an instrument")


class Guitar(Instrument):
    def play(self):
        print("Playing the guitar with strumming and chords")


class Piano(Instrument):
    def play(self):
        print("Playing the piano with keys and melodies")


instruments = [Guitar(), Piano()]

for instrument in instruments:
    instrument.play()

"""# **Answer 7**"""

class MathOperations:
  @classmethod
  def add_numbers(cls,a,b):
    return a+b
  @staticmethod
  def subtract_numbers(a,b):
    return a-b

print("addition of number is:",MathOperations.add_numbers(10,20))
print("subtraction of numbers is:",MathOperations.subtract_numbers(200,150))

"""# **Answer 8**"""

class person:
  count = 0
  def __init__(self,name):
    self.name = name
    person.count = person.count + 1

  def total_person():
    return person.count

obj1 = person("saurabh sharma")
obj2  = person("maverick")
person.total_person()

"""# **Answer 9**"""

class Fraction:
    def __init__(self, numerator, denominator):
        self.numerator = numerator
        self.denominator = denominator

    def __str__(self):
        return f"{self.numerator}/{self.denominator}"


f1 = Fraction(3, 4)
print(f1)

f2 = Fraction(5, 8)
print(f2)

"""# **Answer 10**"""

class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __str__(self):
        return f"({self.x}, {self.y})"


v1 = Vector(2, 3)
v2 = Vector(4, 5)
v3 = v1 + v2
print(v1)
print(v2)
print("Sum of vectors:", v3)

"""# **Answer 11**"""

class perosn:
  def __init__(self,name,age):
    self.name  = name
    self.age = age

  def greet(self):
    print(f"Hello, My name is {self.name} and i am {self.age} years old")

obj = perosn("saurabh sharma",23)
obj.greet()

"""# **Answer 12**"""

class student:
  def __init__(self,name,grades):
    self.name = name
    self.grades = grades

  def average_grade(self):
    if self.grades:
      return sum(self.grades) / len(self.grades)
    else:
      return 0

s = student("saurabh sharma",[90,93,80,87,77])
print(f"The average grade of {s.name} is {s.average_grade()}")

"""# **Answer 13**"""

class Rectangle:
    def __init__(self):
        self.length = 0
        self.width = 0

    def set_dimensions(self, length, width):
        self.length = length
        self.width = width

    def area(self):
        return self.length * self.width

rect = Rectangle()
rect.set_dimensions(5, 10)
print("Area of Rectangle :", rect.area())

"""# **Answer 14**"""

class Employee:
    def __init__(self, name, hourly_rate):
        self.name = name
        self.hourly_rate = hourly_rate

    def calculate_salary(self, hours_worked):
        return self.hourly_rate * hours_worked


class Manager(Employee):
    def __init__(self, name, hourly_rate, bonus):
        super().__init__(name, hourly_rate)
        self.bonus = bonus

    def calculate_salary(self, hours_worked):
        base_salary = super().calculate_salary(hours_worked)
        return base_salary + self.bonus


emp = Employee("Saurabh sharma", 20)
print(f"Employee Salary: {emp.calculate_salary(40)}")

mgr = Manager("Mukul sharma", 30, 500)
print(f"After bonus salary is: {mgr.calculate_salary(40)}")

"""# **Answer 15**"""

class product:
  def __init__(self,name,price,quantity):
    self.name = name
    self.price = price
    self.quantity = quantity

  def total_price(self):
    return self.price * self.quantity

class pen(product):
  def __init__(self,name,price,quantity):
    super().__init__(name,price,quantity)

class book(product):
  def __init__(self,name,price,quantity):
    super().__init__(name,price,quantity)

obj = pen("ball pen",20,1000)
print(f"The total price of {obj.name} is {obj.total_price()}")

obj1 = book("harry potter",500,100)
print(f"The total price of {obj1.name} is {obj1.total_price()}")

"""# **Answer 16**"""

class animal():
  @abstractmethod
  def sound():
    pass

class cow(animal):
  def sound():
    print("this is the sound of a cow")

class sheep(animal):
  def sound():
    print("this is the sound of a sheep")

animal = [(cow),(sheep)]
for i in animal:
  i.sound()

"""# **Answer 17**"""

class book:
  def __init__(self,title,author, year_published):
    self.title = title
    self.author = author
    self.year_published = year_published

  def get_book_info(self):
    return (f"{self.title} by {self.author}  {self.year_published}")

obj = book("Game of thrones","George R. R. Martin,",1996)
obj2 = book("Harry Potter","J.K. Rowling,",1997)
print(obj.get_book_info())
print(obj2.get_book_info())

"""# **Answer 18**"""

class house:
  def __init__(self,address, price):
    self.address = address
    self.price = price

class mansion(house):
  def __init__(self,address,price,number_of_rooms):
    super().__init__(address,price)
    self.number_of_rooms = number_of_rooms

  def details(self):
    return f"The mansion at {self.address} is worth {self.price} and has {self.number_of_rooms} rooms."

obj = mansion("#454 ram nagar",800000,5)
obj.details()